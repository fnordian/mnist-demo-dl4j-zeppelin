{"paragraphs":[{"text":"%spark.dep\nz.reset()\nz.load(\"org.deeplearning4j:deeplearning4j-core:0.9.1\")\nz.load(\"org.nd4j:nd4j-native-platform:0.9.1\")\n","dateUpdated":"2018-03-13T03:20:50+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520910942475_-931390561","id":"20180309-180313_145794191","dateCreated":"2018-03-13T03:15:42+0000","status":"RUNNING","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:161","user":"anonymous","dateFinished":"2018-03-13T03:19:01+0000","dateStarted":"2018-03-13T03:20:50+0000"},{"title":"/home/marcus/prg/scalatest/mnistdemo/docs/downloading-mnist.md","text":"%md\nDownloading the MNIST dataset\n=============================\n\nMNIST is a database of handwritten digits and matching labels. \nConsisting of 60,000 training examples and 10,000 test examples it is a classic machine learning problem, \nwell suited to introduce image recognition algorithms to beginners.\n\nA detailed description of the data and download-links can be found [here](http://yann.lecun.com/exdb/mnist/).\n\nThis project loads the gzipped datafiles directly from there.\n\n  \n","dateUpdated":"2018-03-13T03:15:42+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>Downloading the MNIST dataset</h1>\n<p>MNIST is a database of handwritten digits and matching labels.<br/>Consisting of 60,000 training examples and 10,000 test examples it is a classic machine learning problem,<br/>well suited to introduce image recognition algorithms to beginners.</p>\n<p>A detailed description of the data and download-links can be found <a href=\"http://yann.lecun.com/exdb/mnist/\">here</a>.</p>\n<p>This project loads the gzipped datafiles directly from there.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1520910942482_-921771838","id":"20180313-081240_172118774","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:162"},{"title":"/home/marcus/prg/scalatest/mnistdemo/src/main/scala/HttpDownloader.scala","text":"object HttpDownloader {\n\n  import java.io.File\n  import java.io.{BufferedOutputStream, FileOutputStream, InputStream, OutputStream}\n  import java.net.{HttpURLConnection, URL}\n\n  def fileExists(filename: String): Boolean = {\n    new File(filename).exists()\n  }\n\n  def downloadFile(url: String, filename: String): String = {\n    if (!fileExists(filename)) {\n      val connection = new URL(url).openConnection().asInstanceOf[HttpURLConnection]\n      connection.setRequestMethod(\"GET\")\n      val in: InputStream = connection.getInputStream\n      val fileToDownloadAs = new java.io.File(filename)\n      fileToDownloadAs.getParentFile().mkdirs()\n      val out: OutputStream = new BufferedOutputStream(new FileOutputStream(fileToDownloadAs))\n      val byteArray = Stream.continually(in.read).takeWhile(-1 !=).map(_.toByte).toArray\n      out.write(byteArray)\n\n      out.close()\n      in.close()\n    }\n\n    filename\n  }\n}\n","dateUpdated":"2018-03-13T03:15:42+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520910942482_-921771838","id":"20180313-081239_720662084","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:163"},{"title":"/home/marcus/prg/scalatest/mnistdemo/docs/reading-mnist-images.md","text":"%md\nReading MNIST images\n====================\n\nMNIST images are stored as a set in one gzipped file. After a small header (magicnumber + item, row and col count in msb encoding)\n, all images are concatenated until the of the file.\nEvery image consists of 28x28 bytes, every byte describing one pixel of the image, ordered line-wise from left to right, top to bottom.\n\n    Header:  -------------------------\n     (magic) | 00 01 02 03           |\n     (imgcnt)| 00 01 02 03           |\n     (rowcnt)| 00 01 02 03           |\n     (colcnt)| 00 01 02 03           |\n             -------------------------\n    Image0:  -------------------------\n     (pixels)|00 01 02 04...         |\n             |28 29 30 31...         |\n             |...                    |\n             |...                    |\n             -------------------------\n    Image1:  -------------------------\n     (pixels)|00 01 02 04...         |\n             |28 29 30 31...         |\n             |...                    |\n             |...                    |\n             -------------------------\n\nAll images are stored in one big data object of type ```INDArray```. ```INDArray``` is a multidimensional array,\nallowing highly optimized matrix operations. Deeplearning4j performs ml-algorithms on these data structures.\n\nThe dimensions, or shape of the image-array is (number of images, 28x28). Every row of the array contains all the pixels of one image.","dateUpdated":"2018-03-13T03:15:42+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>Reading MNIST images</h1>\n<p>MNIST images are stored as a set in one gzipped file. After a small header (magicnumber + item, row and col count in msb encoding)<br/>, all images are concatenated until the of the file.<br/>Every image consists of 28x28 bytes, every byte describing one pixel of the image, ordered line-wise from left to right, top to bottom.</p>\n<pre><code>Header:  -------------------------\n (magic) | 00 01 02 03           |\n (imgcnt)| 00 01 02 03           |\n (rowcnt)| 00 01 02 03           |\n (colcnt)| 00 01 02 03           |\n         -------------------------\nImage0:  -------------------------\n (pixels)|00 01 02 04...         |\n         |28 29 30 31...         |\n         |...                    |\n         |...                    |\n         -------------------------\nImage1:  -------------------------\n (pixels)|00 01 02 04...         |\n         |28 29 30 31...         |\n         |...                    |\n         |...                    |\n         -------------------------\n</code></pre>\n<p>All images are stored in one big data object of type <code>INDArray</code>. <code>INDArray</code> is a multidimensional array,<br/>allowing highly optimized matrix operations. Deeplearning4j performs ml-algorithms on these data structures.</p>\n<p>The dimensions, or shape of the image-array is (number of images, 28x28). Every row of the array contains all the pixels of one image.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1520910942483_-922156587","id":"20180313-081240_132786685","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:164"},{"title":"/home/marcus/prg/scalatest/mnistdemo/src/main/scala/ImageViewer.scala","text":"object ImageViewer {\n\n  import java.awt.image.{BufferedImage, _}\n  import java.io.IOException\n\n  import javax.swing.{ImageIcon, JLabel, JOptionPane}\n  import org.nd4j.linalg.api.ndarray.INDArray\n\n  def view(image: INDArray): Unit = {\n    try {\n      val byteimage = image.stride().map(_.toByte)\n      val bufferImage = new DataBufferByte(byteimage, 28 * 28)\n      val bi = new BufferedImage(28, 28, BufferedImage.TYPE_BYTE_GRAY)\n\n      for (y <- 0 to 27) {\n        for (x <- 0 to 27) {\n          val c = (256 * image.getDouble(0, x + 28 * y)).toInt & 255\n          val rgb = (255 << 24) + (c << 16) + (c << 8) + c\n          bi.setRGB(x, y, rgb)\n          print(\" \" + (if (c > 20) \"X\" else \"_\"))\n        }\n        println()\n      }\n\n      val icon = new ImageIcon(bi)\n      val label = new JLabel(icon)\n      // uncomment this to view image\n      //JOptionPane.showMessageDialog(null, label)\n    } catch {\n      case e: IOException =>\n        e.printStackTrace()\n    }\n  }\n}\n","dateUpdated":"2018-03-13T03:15:42+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520910942483_-922156587","id":"20180313-081239_1698758721","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:165"},{"title":"/home/marcus/prg/scalatest/mnistdemo/src/main/scala/ImageReader.scala","text":"object ImageReader {\n\n  import java.io.{FileInputStream, InputStream}\n  import java.util.zip.GZIPInputStream\n\n  import org.nd4j.linalg.api.ndarray.INDArray\n  import org.nd4j.linalg.factory.Nd4j\n\n\n  private def getInputStream(filename: String) =\n    new GZIPInputStream(new FileInputStream(filename))\n\n\n  private def read32BitToInt(inputStream: InputStream) = {\n    var result: Int = 0\n\n    for (i <- 0 to 3) {\n      result = result << 8\n      result |= 0xff & inputStream.read()\n    }\n\n    result\n  }\n\n  private def readHeader(inputStream: InputStream) = {\n    val magicNumber = read32BitToInt(inputStream)\n    val numberOfItems = read32BitToInt(inputStream)\n    val numberOfRows = read32BitToInt(inputStream)\n    val numberOfColums = read32BitToInt(inputStream)\n\n    (magicNumber, numberOfItems, numberOfRows, numberOfColums)\n  }\n\n\n  private def scale(v: Double) = v / 256\n\n  def readtoArray(filename: String, userMaxItems: Int = 0): INDArray = {\n    val in = getInputStream(filename)\n\n    val header = readHeader(in)\n    val rowSize = header._3 * header._4\n    val maxItems = if (userMaxItems == 0 || userMaxItems > header._2) header._2 else userMaxItems\n\n    val imageArray = Nd4j.create(maxItems, rowSize)\n    var (i, j) = (0, 0)\n\n    for (b <- Iterator.continually(in.read()).takeWhile(i < maxItems - 1 && -1 != _)) {\n      j = j + 1\n      if (j % rowSize == 0) {\n        j = 0\n        i = i + 1\n      }\n      imageArray.put(i, j, scale(b.toDouble))\n    }\n\n    imageArray\n  }\n}\n","dateUpdated":"2018-03-13T03:15:42+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520910942483_-922156587","id":"20180313-081239_1029039455","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:166"},{"title":"/home/marcus/prg/scalatest/mnistdemo/docs/reading-mnist-labels.md","text":"%md\nReading MNIST labels\n====================\n\nThe label file format is similar to the images. There is a small header followed by the image labels (magicnumber + item count in msb encoding). \nEvery label is exactly one byte. The labels are in the same order as the images.\n\n    Header:  -------------------------\n     (magic) | 00 01 02 03           |\n     (imgcnt)| 00 01 02 03           |\n             -------------------------\n    Label0:  -------------------------\n             |00                     |\n             -------------------------\n    Label1:  -------------------------\n             |00                     |\n             -------------------------\n\n\nAs with images, the labels are also stored in an ```INDArray```.\n\nBut unlike the images which are stored directly into to array, labels have to reencoded using the OneHot encoding schema. \nThis is required by the ml algorithm we are going to use.","dateUpdated":"2018-03-13T03:15:42+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>Reading MNIST labels</h1>\n<p>The label file format is similar to the images. There is a small header followed by the image labels (magicnumber + item count in msb encoding).<br/>Every label is exactly one byte. The labels are in the same order as the images.</p>\n<pre><code>Header:  -------------------------\n (magic) | 00 01 02 03           |\n (imgcnt)| 00 01 02 03           |\n         -------------------------\nLabel0:  -------------------------\n         |00                     |\n         -------------------------\nLabel1:  -------------------------\n         |00                     |\n         -------------------------\n</code></pre>\n<p>As with images, the labels are also stored in an <code>INDArray</code>.</p>\n<p>But unlike the images which are stored directly into to array, labels have to reencoded using the OneHot encoding schema.<br/>This is required by the ml algorithm we are going to use.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1520910942484_-924080331","id":"20180313-081240_1964284338","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:167"},{"title":"/home/marcus/prg/scalatest/mnistdemo/src/main/scala/LabelReader.scala","text":"object LabelReader {\n\n  import java.io.{FileInputStream, InputStream}\n  import java.util.zip.GZIPInputStream\n\n  import org.nd4j.linalg.api.ndarray.INDArray\n  import org.nd4j.linalg.factory.Nd4j\n\n\n  private def oneHotEncode(n: Int, a: Int): INDArray = {\n    val result = Nd4j.zeros(1, n)\n    result.put(0, a, 1.0)\n    result\n  }\n\n  private def getInputStream(filename: String) =\n    new GZIPInputStream(new FileInputStream(filename))\n\n  private def read32BitToInt(inputStream: InputStream) = {\n    var result: Int = 0\n\n    for (i <- 0 to 3) {\n      result = result << 8\n      result |= 0xff & inputStream.read()\n    }\n\n    result\n  }\n\n  private def readHeader(inputStream: InputStream) = {\n    val magicNumber = read32BitToInt(inputStream)\n    val numberOfItems = read32BitToInt(inputStream)\n\n    (magicNumber, numberOfItems)\n  }\n\n  def readtoArray(filename: String, classCount: Int, userMaxItems: Int = 0): INDArray = {\n    val in = getInputStream(filename)\n\n    val header = readHeader(in)\n    val maxItems = if (userMaxItems == 0 || userMaxItems > header._2) header._2 else userMaxItems\n\n    val labelArray = Nd4j.create(maxItems, classCount)\n    var i = 0\n\n    val labels = for (b <- Iterator.continually(in.read()).takeWhile(i < maxItems - 1 && -1 != _)) {\n      val oh = oneHotEncode(classCount, b)\n      for (j <- 0 to classCount - 1) {\n        labelArray.put(i, j, oh.getScalar(0, j))\n      }\n      i = i + 1\n    }\n\n    labelArray\n  }\n}","dateUpdated":"2018-03-13T03:15:42+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520910942484_-924080331","id":"20180313-081239_1266803594","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:168"},{"title":"/home/marcus/prg/scalatest/mnistdemo/docs/image-classifier-using-nn.md","text":"%md\nImage classifier using a small neural network\n=============================================\n\nWe use deeplearning4j to build an image classification network and feed it the mnist train-dataset.\n\nThe neural net has an inputlayer of size 28x28, 2 hidden, relu-activated layers with 256 and 128 nodes and a softmax output layer with 10 classes. \n\nAfter training, the network is then evaluated using the mnist-test-dataset.\n\nTo further optimize the classifier performance, you can play around with the network configuration and hyper-parameters.\n\nHave a look at the MNIST-homepage for some benchmarks, to see how you are doing.\n\nGood luck!","dateUpdated":"2018-03-13T03:15:42+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>Image classifier using a small neural network</h1>\n<p>We use deeplearning4j to build an image classification network and feed it the mnist train-dataset.</p>\n<p>The neural net has an inputlayer of size 28x28, 2 hidden, relu-activated layers with 256 and 128 nodes and a softmax output layer with 10 classes. </p>\n<p>After training, the network is then evaluated using the mnist-test-dataset.</p>\n<p>To further optimize the classifier performance, you can play around with the network configuration and hyper-parameters.</p>\n<p>Have a look at the MNIST-homepage for some benchmarks, to see how you are doing.</p>\n<p>Good luck!</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1520910942484_-924080331","id":"20180313-081240_1826284559","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:169"},{"title":"/home/marcus/prg/scalatest/mnistdemo/src/main/scala/MnistDemo.scala","text":"object MnistDemo {\n\n  import org.deeplearning4j.nn.api.OptimizationAlgorithm\n  import org.deeplearning4j.nn.conf.NeuralNetConfiguration\n  import org.deeplearning4j.nn.conf.layers.{DenseLayer, OutputLayer}\n  import org.deeplearning4j.nn.multilayer.MultiLayerNetwork\n  import org.deeplearning4j.nn.weights.WeightInit\n  import org.nd4j.linalg.activations.Activation\n  import org.nd4j.linalg.api.ndarray.INDArray\n  import org.nd4j.linalg.lossfunctions.LossFunctions.LossFunction\n\n\n  def reverseOneHot(row: INDArray, classCount: Int): Int = {\n    var result = -1\n    var maxValue = -1.0\n\n    for (i <- 0 to classCount -1) {\n      val rowValue = row.getDouble(i)\n      if (rowValue > maxValue) {\n        maxValue = rowValue\n        result = i\n      }\n    }\n\n    result\n  }\n\n  def test(net: MultiLayerNetwork): Unit = {\n    val testImages = ImageReader.readtoArray(HttpDownloader.downloadFile(\"http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz\", \"data/mnist/t10k-images-idx3-ubyte.gz\"))\n    val testLabels = LabelReader.readtoArray(HttpDownloader.downloadFile(\"http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz\", \"data/mnist/t10k-labels-idx1-ubyte.gz\"), 10)\n\n    val predictions = net.output(testImages)\n    var correctCount: Int = 0\n\n    for (i <- 0 to (predictions.shape()(0)) - 1) {\n      if (reverseOneHot(predictions.getRow(i), 10) == reverseOneHot(testLabels.getRow(i), 10)) {\n        correctCount = correctCount + 1\n      }\n    }\n\n    println(\"correct: \" + correctCount)\n    println(\"exact match ratio: \" + (correctCount.toDouble / predictions.shape()(0).toDouble))\n  }\n\n  def viewExample(itemIdx: Int, net: MultiLayerNetwork): Unit = {\n    ImageViewer.view(net.getInput.getRow(itemIdx))\n\n    val exampleLabel = net.getLabels.getRow(itemIdx)\n    for (i <- 0 to exampleLabel.shape()(1) -1) {\n      print(exampleLabel.getDouble(0, i).toByte)\n    }\n    println()\n  }\n\n  def main(args: Array[String]): Unit = {\n    val hl1Size = 256\n    val hl2Size = 128\n\n    val confBuilder = new NeuralNetConfiguration.Builder()\n      .iterations(1)\n      .learningRate(0.1)\n      .weightInit(WeightInit.XAVIER)\n      .optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT)\n      .list()\n      .layer(0, new DenseLayer.Builder().activation(Activation.RELU).nIn(28 * 28).nOut(hl1Size).build())\n      .layer(1, new DenseLayer.Builder().activation(Activation.RELU).nIn(hl1Size).nOut(hl2Size).build())\n      .layer(2, new OutputLayer.Builder().activation(Activation.SOFTMAX).nIn(hl2Size).nOut(10).lossFunction(LossFunction.MCXENT).build())\n\n    val conf = confBuilder.pretrain(false).backprop(true).build()\n    val net = new MultiLayerNetwork(conf)\n    net.init()\n\n    val maxItems = 0\n\n    net.setInput(ImageReader.readtoArray(HttpDownloader.downloadFile(\"http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz\", \"data/mnist/train-images-idx3-ubyte.gz\"), maxItems))\n    net.setLabels(LabelReader.readtoArray(HttpDownloader.downloadFile(\"http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz\", \"data/mnist/train-labels-idx1-ubyte.gz\"), 10, maxItems))\n    viewExample(123, net)\n\n    net.setInputMiniBatchSize(10)\n    val numberOfEpochs = 10\n    for (epoch <- 1 to numberOfEpochs) {\n      net.fit()\n    }\n\n    test(net)\n  }\n}\n","dateUpdated":"2018-03-13T03:15:42+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520910942485_-924465080","id":"20180313-081239_1888373806","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:170"},{"title":"new note","text":"  MnistDemo.main(Array[String]())","dateUpdated":"2018-03-13T03:15:42+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520910942485_-924465080","id":"20180309-111402_1341197140","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:171"},{"dateUpdated":"2018-03-13T03:15:42+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1520910942485_-924465080","id":"20180311-171249_1068135651","dateCreated":"2018-03-13T03:15:42+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:172"}],"name":"MNIST-Demo with dl4j","id":"2D83UST9X","angularObjects":{"2D9ZWQW13:shared_process":[],"2DAKT54MD:shared_process":[],"2D82G2SE4:shared_process":[],"2DB9P1WRX:shared_process":[],"2DACJB5SX:shared_process":[],"2DBB6MGHH:shared_process":[],"2D8B89SYH:shared_process":[],"2D92QC735:shared_process":[],"2DAEZN5JV:shared_process":[],"2D8WD2E6P:shared_process":[],"2D8AS69CT:shared_process":[],"2D86NQD5T:shared_process":[],"2D97ZH54F:shared_process":[],"2D8SJ7XZG:shared_process":[],"2D8FADR3V:shared_process":[],"2D8PDJXX7:shared_process":[],"2D7WCNEEW:shared_process":[],"2D7SMYNJ2:shared_process":[],"2D9117CQF:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}